# Некоторые современные вопросы безопасности в Linux и способы их решения

В этой статье приводится современный взгляд на некоторые фундаментальные вопросы безопасности в Linux и рекомендации по решению этих вопросов.

::: warning Дисклеймер
Все указанные ниже примеры приведены исключительно как способы проверки той или иной технологии защиты.
:::

## Вопрос выбора между Wayland или Xorg (X11)

Многие пользователи Linux до сих пор не могут определиться с выбором платформы для графического окружения. Особенно среди домашних пользователей существует обширная полемика о том, чем все же лучше пользоваться Wayland или Xorg (X11)? 

С точки зрения безопасности ответ на этот вопрос вполне однозначен. Нужно использовать Wayland и минимизировать использование X11. Почему это так? Причин несколько:

- Протокол X11 (реализацией которого является популярный графический сервер Xorg) разрабатывался в середине восьмидесятых годов прошлого века, когда современные проблемы безопасности просто не считались актуальными, или не существовали вовсе. Поэтому архитектура протокола X11 просто не предусматривает некоторые обязательные теперь вещи, например изоляцию ввода-вывода между окнами сеанса. То есть, сама архитектура протокола X11 сильно устарела;
- Сопровождение этой архитектуры чрезвычайно затруднено, особенно учитывая требования обратной совместимости и необходимость знать вещи, которые были нужны лет тридцать или больше назад, сейчас давно устаревшие и не используемые;
- Устранять уязвимости становится все тяжелее.

Всё это приводит к тому, что современные дистрибутивы Linux уже начали процесс постепенного отказа от X11 в пользу Wayland. И ALT Linux не исключение. В дистрибутивах на одиннадцатой платформе и Sisyphus система по умолчанию загружает сеанс Wayland. 

Чтобы проверить, в каком графическом окружении выполняется текущий сеанс, можно выполнить команду:

```sh
$ echo $XDG_SESSION_TYPE 
wayland
```

В ответ система вернёт значение графического окружения.

### Простой тест перехвата ввода в X11

Как уже отмечалось выше, основная проблема протокола X11 — это отсутствие изоляции ввода в графическом сеансе. Проще говоря, когда пользователь вводит информацию в любом окне своего сеанса, этот ввод перехватывается функцией `xinput()` графического сервера Xorg и транслируется всем остальным окнам в том же сеансе. А окно приложения, которому адресован ввод, само забирает и обрабатывает эти символы. Но, повторим, поступает этот ввод абсолютно всем окнам текущего сеанса. 

То есть, на практике, Xorg — это фактически встроенный в систему перехватчик клавиатурного ввода (сниффер), от которого нельзя избавиться, так как это проблема архитектуры. Это было заложено в протокол X11 много десятков лет назад. 

А если в графическом сеансе X11/Xorg запущено вредное (недоверенное) графическое приложение, то оно также получит весь пользовательский ввод. Что такое приложение с этим вводом потом сделает -- определенно сказать невозможно, не подвергнув приложение динамическому анализу (это как мимнимум). В целом, может сделать всё, что угодно: записать то, что пользователь вводит в текстовый файл, который потом отправит куда-нибудь, или сразу отправит поток ввода куда-то, и т.п.

Для того, чтобы продемонстрировать недостатки изоляции ввода в пртоколе X11 можно сделать следующее:

1. Переключиться в сеанс Xorg и проверить, действительно ли переключение произошло:

```sh
$ echo $XDG_SESSION_TYPE
x11
```

2. Установить пакет ```xinput``` (от имени ```root``` или используя ```sudo```):

```sh
apt-get install xinput
```

3. Вывести (уже от имени пользователя, это важно) список текущих устройств ввода:

```sh
$ xinput list
⎡ Virtual core pointer
id=2 [master pointer (3)]
⎜ ↳ Virtual core XTEST pointerid=4 [slave pointer (2)]
⎜ ↳ VirtualPS/2 VMware VMMouseid=8 [slave pointer (2)]
⎜ ↳ VirtualPS/2 VMware VMMouseid=9 [slave pointer (2)]
⎜ ↳ spice vdagent tabletid=10 [slave pointer (2)]
⎣ Virtual core keyboardid=3 [master keyboard (2)]
↳ Virtual core XTEST keyboard
↳ Power Button
id=5 [slave keyboard (3)]
id=6 [slave keyboard (3)]
↳ AT Translated Set 2 keyboard
id=7 [slave keyboard (3)]
```

4. Обычно клавиатура имеет имя вроде ```AT Translated keyboard```, в текущем примере её идентификатор это семь. Затем от имени пользователя выполнить перехват ввода:

```sh
$ xinput test 7
```

5. Далее можно запустить любой браузер, открыть страницу с вашей почтой и авторизоваться на ней, введя имя или паоль. Потом переключиться обратно в терминал, и убедиться, что весь ввод перехватывается по числовым идентификаторам клавиш, например:

```sh
key press   64
key release 64
```

6. Совсем несложно вывести в текстовый файл полную таблицу используемых символов, а затем просто вычислить ввод:

```sh
$ xmodmap -pk > listkeys.txt
```

### Что делать

С точки зрения информационной безопасности можно рекомендовать следующее:

- Использовать только Wayland, и исключить (или чрезвычайно минимизировать использование X11/Xorg);
- Использовать программы входа в систему, которые сразу поддерживают Wayland (например, GDM);
- Следить за тем, чтобы по умолчанию менеджер входа загружал сессию Wayland. Или можно поступить ещё радикальнее: например, можно удалить или перенести файлы сессий Xorg ```/usr/share/xsessions/*.desktop```, оставив возможность использовать только сессии Wayland;
- Если уж отказаться от использования X11/Xorg по каким-то причинам нельзя, то постараться применять программы, полученные только из официальных источников Альт Линукс. Лучше избегать установки незнакомых приложений, полученных из сторонних источников, а также применять возможности фильтра пакетов;
- Применять двухфакторную или двухшаговую аутентификацию, что существенно усложнит возможности атаковать систему или программу, даже если пароль уже скомпрометирован.
- Использовать современный дистрибутив и регулярно обновлять его. Поддержка Wayland постоянно совершенствуется. 

## Вопрос использования PulseAudio

Многие пользователи по прежнему продолжают использовать звуковой сервер PulseAudio. В то время, как в операционных системах семейства Альт начиная с одиннадцатой платформы по умолчанию предлагается использовать звуковой сервер PipeWire. В десятой платформе можно переключиться с использования PulseAudio на использование PipeWire. 

В чем же здесь вопрос? Вопрос здесь концептуально полностью аналогичен предыдущему. Дело в том, что звуковой сервер PulseAudio проектировался 20 лет назад (еще в 2004 году, под именем Polypaudio). И у него тоже большие проблемы с изоляцией между приложениями. 

### Простые тесты на проверку изоляции приложений в PulseAudio

Например, вот такой примерно командой можно получить доступ к уже смикшированному звуку других приложений (включая чужие приложения):

```sh
$ parec --file-format=wav -d $(pactl list sinks | grep Name | cut -d: -f2 | head).monitor snooped-audio.wav
```

Или вот такой командой можно получить доступ к микрофону занятому другим приложением (включая чужое приложение) и получить весь входной поток звука, попадающий в микрофон:


```sh
$ parec --file-format=wav -d $(pactl list sources | grep Name | grep -v '\.monitor' | cut -d: -f2 | head) microphone-audio.wav
```

А, например, вот такой командой можно приостановить аудиопоток любых приложений:

```sh
$ pactl suspend-sink $(pactl list sinks | grep Name | cut -d: -f2 | head) 1
```

С помощью PulseAudio можно даже создать простенький сетевой сервер и повесить его на все сетевые адреса компьютера не имея полномочий aдминистратора ```root```:

```sh
$ pactl load-module module-native-protocol-tcp listen=0.0.0.0 port=1234
```

А вот такой простой сценарий фактически инициирует локальный «отказ в обслуживании» (для слабого компьютера) сервера PulseAudio:

```sh
#!/bin/bash

wget -nc https://archive.org/download/TenMinutesOfWhiteNoisePinkNoiseAndBrownianNoise/WhiteNoise.flac

for i in {1..60}; do
    echo "Client #$i";
    pacat --latency-msec=5000 --rate=384000 WhiteNoise.flac &
    sleep 1
done
```

Существует много открыто опубликованных в сети эксплойтов, которые позволяют удаленно воздействовать на сервер PulseAudio и прерывать его работу.

### Что делать

С точки зрения информационной безопасности можно рекомендовать следующее:

- Использовать только PipeWire, и исключить (или чрезвычайно минимизировать использование PulseAudio). К счастью, в операционных системах семейства Альт начиная с одинадцатой платформы звуковой сервер PipeWire используется по умолчанию. Для тех, кто использует более раннюю платформу -- опубликовано руководство по переходу с PulseAudio на PipeWire. Ознакомиться с ним можно тут: <https://www.altlinux.org/Pipewire>;
- Использовать фильтр пакетов, чтобы, как минимум, блокировать возможности удалённого воздействия на звуковую подсистему;
- Осознанно принимать решения, когда приложение пытается запросить доступ к звуковому устройству, например, к микрофону;
- Настроить индикацию приложений во время использования звуковых устройств. Большинство графических окружений и браузеров умеют отображать специальный значок, когда используется камера или микрофон.

## Вопрос использования пользовательских пространств имён

Пользовательские пространства имён это довольно удобный и эффективный механизм изоляции в ядре Linux. Он позволяет пользователям создавать изолированные друг от друга пространства. Используется этот механизм для «песочниц» (sandbox) в некоторых приложениях. Например, браузер Google Chrome использует этот механизм для изоляции страниц друг от друга, и от доступа к файлам пользователей. На его базе работают т.н. «rootless» контейнеры (не требующие для своего запуска полномочий администратора ```root```), Система управления приложениями Flatpak тоже может его использовать, как и некоторые другие приложения.

Проверить, разрешено пользователю создавать пространства имён или нет довольно просто. Достаточно посмотреть соответствующую переменную ядра ОС:

```sh
$ cat /proc/sys/kernel/unprivileged_userns_clone
```

Если в ответ на эту команду вернется единица -- то создание пользовательских пространств имён в системе разрешено. Если ноль -- то запрещено. 

## Вопрос запуска SUID программ 

## Вопрос обработки функций в оболочке

